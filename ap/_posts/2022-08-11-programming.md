---
title: プログラミングの用語
category: ap
comment: true
updated: 2022-08-15
---


## リスト
### 連結リスト
任意の要素への追加は必ずしも高速ではないが、追加・削除を得意とするデータ構造.  

|連結リストの種類|特徴|
|---|---|
|単方向リスト|各データは次データへのポインタを持つ|
|双方向リスト|各データは前と後ろのデータへのポインタを持つ|
|循環リスト|各データは次データへのポインタを持ち、末尾のデータは先頭データへのポインタを持つ|

連結リストでは、データ間をポインタで関連づけるため、データの削除や追加は、ポインタの付け替えだけで行える. 連結リストは、動的に領域を確保するデータ構造に適している.  

### 単方向リストでのデータの追加と削除

HeadとTailを持つ単方向リストにおいては、

#### データの追加
データの追加は、リストの先頭で行っても最後尾で行っても、その処理量は同じ.  
Headのポインタ、またはTailのポインタを追加するデータのポインタに置き換えるだけで良い.  

#### データの削除
データの削除(読み出しの後で削除)は、リストの先頭で行うよりも最後尾で行う方が処理量が多くなる.  
HeadとTailを持つ単方向のリストでは、
- データの追加と削除を先頭で行うスタックとして
- データの追加は最後尾で行い、削除は先頭で行うキューとして

用いることができる.  
従って、**要素の追加は最後尾、取り出しは先頭で行うキュー(FIFO)に適している**.  

##### リストの先頭の場合
Headの持つポインタを次の要素のポインタに置き換える.  

##### リストの最後尾の場合
- Headから削除データまでたどる
- 削除する要素の前の要素のポインタをNULLに設定する
- Tailに削除する要素の前の要素のポインタを設定する.  


### リストによる2分木の表現

2分木を表現するときの、ノードのデータ構造  

|Key|Parent|Left|Right|
|---|---|---|---|
|格納する値|親のアドレス|左の子要素のアドレス|右の子要素のアドレス|


## スタックとキュー
### スタック
最後に格納したデータから順に取り出せるLIFO(後入れ先出し)のデータ構造. データのスタックへの挿入はPUSH, 取り出しはPOPの操作で行う.  

### キュー
最初に格納したデータから順に取り出されるFIFO(先入れ先出し)のデータ構造. データの挿入はENQ, 取り出しはDEQの操作で行う.  

### グラフの探索
深さ優先探索ではスタックを、幅優先探索ではキューを使用する.  

## 木
木は、データどうしの階層的な関係を表現するためのデータ構造.  
節からでる枝が2本である木を2分木、n本である木をn分木(多分木)という.  

### 完全2分木
葉以外の節は全て2つの子をもち、根から葉までの深さが全て等しい木を完全2分木という.  

|葉の個数|葉以外の節の個数|
|---|---|
|2<sup>H</sup>|2<sup>H</sup> - 1 |



### 2分探索木
節にデータをもたせ、木の性質を用いて探索を行うことができる木を探索木という.  

#### 幅優先探索
分岐が多くなるよう、根に近い節から順に探索する. 

#### 深さ優先探索
根からできるだけ分岐せずに、できるだけ深く探索する. 葉に達したら、1つ前の節に戻って他方を探索する.  

先行順、中間順、後行順の3つの巡回方法がある.  
各節に持たせるデータは、`任意の節の値は、その左部分木のどの値よりも大きく、かつ、その右部分木のどの値よりも小さい`という条件がある.  
従って、2分探索木を中間順で巡回すると
昇順に整列されたデータを得ることができる.  

#### 探索の計算量
2分探索木における探索の計算量は、枝分かれしている節の深さに依存する.  
最大比較回数はlog<sub>2</sub>nとなるが、片方のみに偏った2分探索木では最悪計算量nとなる.  

#### 2分探索木における節の挿入と削除

|削除処理|対応|
|---|---|
|削除する節が葉の場合|単純にその葉を削除する|
|削除する節が左右どちらかの部分木しか持たない場合|削除する節をその子で置き換える|
|削除する節が左右の部分木を持つ場合|削除する節を左部分木中の最大値を持つ節か、右部分木中の最小値を持つ節で置き換える|





### バランス木
根から葉までの深さがほぼ一定になるように作られた木.  

#### AVL木
任意の節において左右の部分木の高さの差が1以下の木.  

#### B木
外部記憶装置にデータを格納するために考えられた多分木のデータ構造.  

B木の節のデータ構造  
|p0|k1|p1|k2|p2|...|...|kn|pn|
|---|---|---|---|---|---|---|---|---|


- キーを偶数個格納できる
- pには子へのポインタが格納される
- k葉昇順に並んでいる

##### キーの探索
2分木探索と同じく、根から順に、各節に格納されているキーと探索キーを比較し、ポインタをたどることで目的のキーが存在する節を探索する.  

##### B<sup>+</sup>木インデックス
B<sup>+</sup>木の構造を利用したインデックス. 関係データベースで使用される.  大量データでも検索パフォーマンスが得られることと、範囲検索に優れていることがメリット.  

---

## 探索アルゴリズム
### 線形探索法
探索対象データの先頭から順に探索していく方法. 平均して, $(n+1)/2$の比較で探索ができる.  つまり計算量のオーダは$O(n)$である.  

### 番兵法
終了判定を「データが見つかったか」だけに簡素化して、計算量を抑えるための方法.  
探索データと同じデータを探索対象データの末尾に追加する.  

### 2分探索法
大小比較を使う探索法のうちで最もシンプルな探索法. 昇順または降順に整列されたデータに対してのみ用いることができる.  
計算量のオーダは`O(log_2 n)`

### ハッシュ法
探索時間のスピードを上げる探索方法. 探索データのキー値により、そのデータの格納ばしょを直接計算する.  
一意探索に優れていて、線形探索法や2分探索法に比べて探索時間が短く済むが、連続したデータの探索には向かない.  

`ハッシュ関数`: 格納場所の算出に用いる関数  
`ハッシュ値`: あるキー値からハッシュ関数により求められる値  

#### シノニムの発生(衝突)
異なるキー値から同一のハッシュ値が求められること. これを抑えるには、偏りがない一様分布となるようにハッシュ関数を決める必要があるが、完璧に偏りがない関数の実装は現実的ではないとされている.  
そこで、下記の対策がある.

##### オープンアドレス法
シノニムが発生した時、別のハッシュ関数を用いて再ハッシュを行う方法. 


##### チェイン法
同じハッシュ値を持つデータをポインタで繋いだリストとして格納する方法.  
計算量は`N/M`に依存する.  


##### 計算量の大小関係
O(1) < O(log_2 n) < O(n) < O(n*log_2 n) < O(n^2) <O(2^n) < O(n!)

---


## 整列アルゴリズム
### 基本的な整列アルゴリズム

|アルゴリズム&nbsp;&nbsp;&nbsp;&nbsp;|計算量|説明|
|----|----|---|
|バブルソート|n<sup>2</sup>|隣り合う要素の値を比較し、大小関係が逆になっていれば交換する |
|単純選択法|n<sup>2</sup>|未整列の要素の中から最も小さい要素を選択し、未整列部分の先頭の要素と入れ替える|
|単純挿入法|最悪の場合: n<sup>2</sup>, 最良の場合: n|未整列要素の並びの先頭の要素を取り出し、その要素を整列ずみの要素の中の正しい位置に挿入していく|



### 高速な整列アルゴリズム
#### クイックソート
整列対象データの中から中間的な基準値を決め、その基準値よりも大きな値を集めた区分と、小さな値を集めた区分とに整列対象データを分割し、それぞれの区分の中で再度基準値を決め、同様の処理をデータ数が1つになるまで繰り返すという方法.  
分割統治の考え方を利用した整列法であり、高速に整列できるが、安定ではなく、分割のアルゴリズムに再帰処理を用いているところが特徴.  
平均計算量は,O(nlog<sub>2</sub>n). ただし、最悪計算量は、O(n<sup>2</sup>)(最大値または最小値を基準に選択した場合).  

#### ヒープソート
未整列のデータを、ヒープと呼ばれる、各節の値に「親が持つデータ <= 子が持つデータ」という関係を持たせた`順序木`を作成し、これを配列で表現する. そして、ヒープの根となった最小値を取り出し、既整列の部分に移し、ヒープを再構成する.  
この操作を繰り返し、未整列部分を徐々に縮めていく整列法.  
高速に整列することができ、どんなデータ列に対しても計算量はO(nlog<sub>2</sub>n)だが、安定ではない.  



#### マージソート
整列対象データ列の分割と併合を繰り返して、最終的に１つの整列ずみデータ列を作る整列法.  分割統治の考え方を利用した整列法.  
計算量はどんなデータ列に対してもO(nlog<sub>2</sub>n)であり、安定な整列法.  
データ数の半分程度の作業領域を必要とするのも特徴.  

---


## プログラム言語
### プログラム特性
#### 再入可能
リエントラント.  
複数のタスクから同時に呼び出されても、それぞれに対して正しい結果を返すことができるプログラム. 

#### 再帰
リカーシブ.  
手続きの中で自分自身を呼び出して使うことができるプログラム.  

#### 再使用可能
リユーザブル.  
一度実行したプログラムをロードし直さずに再度実行しても、正しい結果を返すことができるプログラム.  

#### 再配置可能
リロケータブル.  
プログラムを主記憶上どのアドレスに配置しても実行できるようにしたプログラム.  
具体的にはベースレジスタに主記憶上のプログラムの先頭アドレスを設定し、命令を実行する際、このベースレジスタの値をアドレス部のアドレスの値に加え、それを有効アドレスとすることで、プログラムがどのアドレスに配置されてもプログラムを変更せずに実行できる.  


