---
title: プログラミングの用語
category: ap
comment: true
updated: 2022-08-15
---


## リスト
### 連結リスト
任意の要素への追加は必ずしも高速ではないが、追加・削除を得意とするデータ構造.  

|連結リストの種類|特徴|
|---|---|
|単方向リスト|各データは次データへのポインタを持つ|
|双方向リスト|各データは前と後ろのデータへのポインタを持つ|
|循環リスト|各データは次データへのポインタを持ち、末尾のデータは先頭データへのポインタを持つ|

連結リストでは、データ間をポインタで関連づけるため、データの削除や追加は、ポインタの付け替えだけで行える. 連結リストは、動的に領域を確保するデータ構造に適している.  

### 単方向リストでのデータの追加と削除

HeadとTailを持つ単方向リストにおいては、

#### データの追加
データの追加は、リストの先頭で行っても最後尾で行っても、その処理量は同じ.  
Headのポインタ、またはTailのポインタを追加するデータのポインタに置き換えるだけで良い.  

#### データの削除
データの削除(読み出しの後で削除)は、リストの先頭で行うよりも最後尾で行う方が処理量が多くなる.  
HeadとTailを持つ単方向のリストでは、
- データの追加と削除を先頭で行うスタックとして
- データの追加は最後尾で行い、削除は先頭で行うキューとして

用いることができる.  
従って、**要素の追加は最後尾、取り出しは先頭で行うキュー(FIFO)に適している**.  

##### リストの先頭の場合
Headの持つポインタを次の要素のポインタに置き換える.  

##### リストの最後尾の場合
- Headから削除データまでたどる
- 削除する要素の前の要素のポインタをNULLに設定する
- Tailに削除する要素の前の要素のポインタを設定する.  


### リストによる2分木の表現

2分木を表現するときの、ノードのデータ構造  

|Key|Parent|Left|Right|
|---|---|---|---|
|格納する値|親のアドレス|左の子要素のアドレス|右の子要素のアドレス|


## スタックとキュー
### スタック
最後に格納したデータから順に取り出せるLIFO(後入れ先出し)のデータ構造. データのスタックへの挿入はPUSH, 取り出しはPOPの操作で行う.  

### キュー
最初に格納したデータから順に取り出されるFIFO(先入れ先出し)のデータ構造. データの挿入はENQ, 取り出しはDEQの操作で行う.  

### グラフの探索
深さ優先探索ではスタックを、幅優先探索ではキューを使用する.  

## 木
木は、データどうしの階層的な関係を表現するためのデータ構造.  
節からでる枝が2本である木を2分木、n本である木をn分木(多分木)という.  

### 完全2分木
葉以外の節は全て2つの子をもち、根から葉までの深さが全て等しい木を完全2分木という.  

|葉の個数|葉以外の節の個数|
|---|---|
|2<sup>H</sup>|2<sup>H</sup> - 1 |



### 2分探索木
節にデータをもたせ、木の性質を用いて探索を行うことができる木を探索木という.  

#### 幅優先探索
分岐が多くなるよう、根に近い節から順に探索する. 

#### 深さ優先探索
根からできるだけ分岐せずに、できるだけ深く探索する. 葉に達したら、1つ前の節に戻って他方を探索する.  

先行順、中間順、後行順の3つの巡回方法がある.  
各節に持たせるデータは、`任意の節の値は、その左部分木のどの値よりも大きく、かつ、その右部分木のどの値よりも小さい`という条件がある.  
従って、2分探索木を中間順で巡回すると
昇順に整列されたデータを得ることができる.  

#### 探索の計算量
2分探索木における探索の計算量は、枝分かれしている節の深さに依存する.  
最大比較回数はlog<sub>2</sub>nとなるが、片方のみに偏った2分探索木では最悪計算量nとなる.  

#### 2分探索木における節の挿入と削除

|削除処理|対応|
|---|---|
|削除する節が葉の場合|単純にその葉を削除する|
|削除する節が左右どちらかの部分木しか持たない場合|削除する節をその子で置き換える|
|削除する節が左右の部分木を持つ場合|削除する節を左部分木中の最大値を持つ節か、右部分木中の最小値を持つ節で置き換える|





### バランス木
根から葉までの深さがほぼ一定になるように作られた木.  

#### AVL木
任意の節において左右の部分木の高さの差が1以下の木.  

#### B木
外部記憶装置にデータを格納するために考えられた多分木のデータ構造.  

B木の節のデータ構造  

|p0|k1|p1|k2|p2|...|...|kn|pn|
|---|---|---|---|---|---|---|---|---|

- キーを偶数個格納できる
- pには子へのポインタが格納される
- k葉昇順に並んでいる

##### キーの探索
2分木探索と同じく、根から順に、各節に格納されているキーと探索キーを比較し、ポインタをたどることで目的のキーが存在する節を探索する.  

##### B<sup>+</sup>木インデックス
B<sup>+</sup>木の構造を利用したインデックス. 関係データベースで使用される.  大量データでも検索パフォーマンスが得られることと、範囲検索に優れていることがメリット.  

---

## 探索アルゴリズム
### 線形探索法
探索対象データの先頭から順に探索していく方法. 平均して, $(n+1)/2$の比較で探索ができる.  つまり計算量のオーダは$O(n)$である.  

### 番兵法
終了判定を「データが見つかったか」だけに簡素化して、計算量を抑えるための方法.  
探索データと同じデータを探索対象データの末尾に追加する.  

### 2分探索法
大小比較を使う探索法のうちで最もシンプルな探索法. 昇順または降順に整列されたデータに対してのみ用いることができる.  
計算量のオーダは`O(log_2 n)`

### ハッシュ法
探索時間のスピードを上げる探索方法. 探索データのキー値により、そのデータの格納ばしょを直接計算する.  
一意探索に優れていて、線形探索法や2分探索法に比べて探索時間が短く済むが、連続したデータの探索には向かない.  

`ハッシュ関数`: 格納場所の算出に用いる関数  
`ハッシュ値`: あるキー値からハッシュ関数により求められる値  

#### シノニムの発生(衝突)
異なるキー値から同一のハッシュ値が求められること. これを抑えるには、偏りがない一様分布となるようにハッシュ関数を決める必要があるが、完璧に偏りがない関数の実装は現実的ではないとされている.  
そこで、下記の対策がある.

##### オープンアドレス法
シノニムが発生した時、別のハッシュ関数を用いて再ハッシュを行う方法. 


##### チェイン法
同じハッシュ値を持つデータをポインタで繋いだリストとして格納する方法.  
計算量は`N/M`に依存する.  


##### 計算量の大小関係
$$  
O(1) < O(log_2 n) < O(n) < O(n*log_2 n) < O(n^2) <O(2^n) < O(n!)
$$

---



