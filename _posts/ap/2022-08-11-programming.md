---
title: プログラミングの用語
category: ap
comment: true
---


## リスト
### 連結リスト
任意の要素への追加は必ずしも高速ではないが、追加・削除を得意とするデータ構造.  

|連結リストの種類|特徴|
|---|---|
|単方向リスト|各データは次データへのポインタを持つ|
|双方向リスト|各データは前と後ろのデータへのポインタを持つ|
|循環リスト|各データは次データへのポインタを持ち、末尾のデータは先頭データへのポインタを持つ|

連結リストでは、データ間をポインタで関連づけるため、データの削除や追加は、ポインタの付け替えだけで行える. 連結リストは、動的に領域を確保するデータ構造に適している.  

### 単方向リストでのデータの追加と削除

HeadとTailを持つ単方向リストにおいては、

#### データの追加
データの追加は、リストの先頭で行っても最後尾で行っても、その処理量は同じ.  
Headのポインタ、またはTailのポインタを追加するデータのポインタに置き換えるだけで良い.  

#### データの削除
データの削除(読み出しの後で削除)は、リストの先頭で行うよりも最後尾で行う方が処理量が多くなる.  
HeadとTailを持つ単方向のリストでは、
- データの追加と削除を先頭で行うスタックとして
- データの追加は最後尾で行い、削除は先頭で行うキューとして

用いることができる.  
従って、**要素の追加は最後尾、取り出しは先頭で行うキュー(FIFO)に適している**.  

##### リストの先頭の場合
Headの持つポインタを次の要素のポインタに置き換える.  

##### リストの最後尾の場合
- Headから削除データまでたどる
- 削除する要素の前の要素のポインタをNULLに設定する
- Tailに削除する要素の前の要素のポインタを設定する.  


### リストによる2分木の表現

2分木を表現するときの、ノードのデータ構造  

|Key|Parent|Left|Right|
|---|---|---|---|
|格納する値|親のアドレス|左の子要素のアドレス|右の子要素のアドレス|


## スタックとキュー
### スタック
最後に格納したデータから順に取り出せるLIFO(後入れ先出し)のデータ構造. データのスタックへの挿入はPUSH, 取り出しはPOPの操作で行う.  

### キュー
最初に格納したデータから順に取り出されるFIFO(先入れ先出し)のデータ構造. データの挿入はENQ, 取り出しはDEQの操作で行う.  

### グラフの探索
深さ優先探索ではスタックを、幅優先探索ではキューを使用する.  

## 木
木は、データどうしの階層的な関係を表現するためのデータ構造.  
節からでる枝が2本である木を2分木、n本である木をn分木(多分木)という.  

### 完全2分木
葉以外の節は全て2つの子をもち、根から葉までの深さが全て等しい木を完全2分木という.  

|葉の個数|葉以外の節の個数|
|---|---|
|2<sup>H</sup>|2<sup>H</sup> - 1 |



### 2分探索木
節にデータをもたせ、木の性質を用いて探索を行うことができる木を探索木という.  

#### 幅優先探索
分岐が多くなるよう、根に近い節から順に探索する. 

#### 深さ優先探索
根からできるだけ分岐せずに、できるだけ深く探索する. 葉に達したら、1つ前の節に戻って他方を探索する.  

先行順、中間順、後行順の3つの巡回方法がある.  
各節に持たせるデータは、`任意の節の値は、その左部分木のどの値よりも大きく、かつ、その右部分木のどの値よりも小さい`という条件がある.  
従って、2分探索木を中間順で巡回すると
昇順に整列されたデータを得ることができる.  

#### 探索の計算量
2分探索木における探索の計算量は、枝分かれしている節の深さに依存する.  
最大比較回数はlog<sub>2</sub>nとなるが、片方のみに偏った2分探索木では最悪計算量nとなる.  

#### 2分探索木における節の挿入と削除

|削除処理|対応|
|---|---|
|削除する節が葉の場合|単純にその葉を削除する|
|削除する節が左右どちらかの部分木しか持たない場合|削除する節をその子で置き換える|
|削除する節が左右の部分木を持つ場合|削除する節を左部分木中の最大値を持つ節か、右部分木中の最小値を持つ節で置き換える|



